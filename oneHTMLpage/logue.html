<html>

<head>
    <meta name="description" content="Game like rogue">
    <meta name="author" content="Leo Muller">
    <meta name="github" content="UncleLeo037">

    <title>A game like Rogue!!!</title>
    <style>
        * {
            background-color: black;
            color: black;
            font-family: monospace;
            text-align: center;
            text-wrap: nowrap;
            cursor: context-menu;
            overflow: hidden;
            text-decoration: none;

            /* disables text highlighting on Standard syntax, Safari, IE 10 and IE 11 respectively */
            /*user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;*/
        }

        #HUD, #start {
            transform: scaleX(1.5);
        }

        #display {
            transform: scaleY(0.5);
            font-size: xx-large;
        }

        .visible,
        .visible * {
            color: white;
            background-color: black;
        }

        a:hover {
            cursor: pointer;
            color: black;
            background-color: white;
        }

        .heart {
            display: inline-block;
            transform: rotate(-90deg);
            letter-spacing: -3px;
            width: 13px;
        }
    </style>
</head>

<body>
    <div id="start" class="visible">
        <h1> - - - Logue - - - </h1>
        <a onclick="start()">NEW GAME</a>
    </div>

    <header id="HUD" class="visible" style="display: none;">
        <div id="menu">
            <a>equipment</a>
            |
            <a>inventory</a>
            |
            <a>character</a>
            |
            <a>settings</a>
        </div>
        <div id="health" style="text-align: left; margin-left: 30%">
            Health
            <br><span id="hp"></span>
        </div>
    </header>

    <div id="display"></div>

    <footer style="display: none;">
        <pre id="legend">
            player = i
            portal = @

            chest = open: H, closed: A

            monsters:
                ghost = ;
                headless = l
                bug = *
                slime = ~
                snake = s
                ghoul = j
        </pre>
    </footer>
</body>

<script>
    //starting parameters for map size
    const GRID_HEIGHT = 32
    const GRID_WIDTH = GRID_HEIGHT * 2
    const NUM_ROOMS = 6
    const MIN = 5
    const MAX = 10
    const LOOT = 5 // % chance of chest spawning per tile

    //constant html elements
    const h_wall = "<span class='visible'>=</span>"
    const v_wall = "<span class='visible'>|</span>"
    const back = "_"
    const floor = "-"

    const player = {
        x: null,
        y: null,
        inventory: [],
        hp: 2,
        atk: 1,//physical attack power
        mgk: 0,//magical attack power
        def: 0,//physical defence
        res: 0,//magical defence
        awr: 2,//awareness
        toString() {
            return "<span class='visible'>i</span>"
        }
    }

    class Chest {
        #isOpen
        constructor() {
            this.#isOpen = false;
        }
        open() {
            this.#isOpen = true;
            //code to give player loot
        }
        toString() {
            if (this.#isOpen) {
                return "<span class='visible'>H</span>"
            }
            return "<span class='visible'>A</span>"
        }
    }

    const shield = "<span class='shield'>ED&nbsp;</span>"
    const heart = "<span class='heart'>&lt;3</span>"
    const portal = "<span class='visible'>@</span>"

    //monsters
    const slime = "<span class='visible'>~</span>"
    const ghost = "<span class='visible'>;</span>"
    const crawl = "<span class='visible'>*</span>"
    const bhead = "<span class='visible'>l</span>"

    //the map is public as changes will be made to it often
    const MAP = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH))

    const monsters = []

    //main game control function
    function handleInput(key) {
        switch (key) {
            case "w":
                if (MAP[player.y - 1][player.x] === floor) {
                    MAP[player.y][player.x] = floor
                    player.y--
                    MAP[player.y][player.x] = player
                } else {
                    interact({ x: player.x, y: player.y - 1 })
                }
                break;
            case "a":
                if (MAP[player.y][player.x - 1] === floor) {
                    MAP[player.y][player.x] = floor
                    player.x--
                    MAP[player.y][player.x] = player
                } else {
                    interact({ x: player.x - 1, y: player.y })
                }
                break;
            case "s":
                if (MAP[player.y + 1][player.x] === floor) {
                    MAP[player.y][player.x] = floor
                    player.y++
                    MAP[player.y][player.x] = player
                } else {
                    interact({ x: player.x, y: player.y + 1 })
                }
                break;
            case "d":
                if (MAP[player.y][player.x + 1] === floor) {
                    MAP[player.y][player.x] = floor
                    player.x++
                    MAP[player.y][player.x] = player
                } else {
                    interact({ x: player.x + 1, y: player.y })
                }
                break;
            case "e":
                player.hp--
                break;
        }
        monsters.forEach(monster => {
            //code for each monster to do something
        })
        console.log(player.hp)
        arrayToHTML()
        if (player.hp <= 0) {
            document.getElementById("HUD").style.display = "none"
            document.getElementById("display").innerHTML = "<div class='visible'>GAME OVER<br><br> press <a href=''>[HERE]</a> to play again<div>"
        }
    }

    function start() {
        document.getElementById("start").style.display = "none"
        document.getElementById("HUD").style.display = "block"
        generate()
        document.addEventListener("keydown", event => { handleInput(event.key) })
        player.hp = 2
    }

    function arrayToHTML() {
        let health = ""
        for (let i = 0; i < player.hp; i++) {
            health += heart
        }
        document.getElementById("hp").innerHTML = health
        let hyperText = ""
        for (let i = 0; i < MAP.length; i++) {
            hyperText += MAP[i].join("") + "<br>"
        }
        document.getElementById("display").innerHTML = hyperText
    }

    function interact(i) {
        if (MAP[i.y][i.x] instanceof Chest) {
            MAP[i.y][i.x].open()
        }
        if (MAP[i.y][i.x] === portal) {
            generate()
        }
    }
</script>

<!--Dungeon Generation Methods-->
<script>
    function generate() {
        //make map empty
        MAP.forEach(line => line.fill(back))

        //create and place rooms
        let coords = []
        while (coords.length < NUM_ROOMS) {
            let room = {
                height: Math.floor(Math.random() * (MAX - MIN)) + MIN,
                width: Math.floor(Math.random() * (MAX - MIN)) + MIN,
                yCoord: Math.floor(Math.random() * GRID_HEIGHT),
                xCoord: Math.floor(Math.random() * GRID_WIDTH),
            }
            if (!(room.xCoord + room.width > GRID_WIDTH || room.yCoord + room.height > GRID_HEIGHT)) {
                coords.push({
                    y: room.yCoord + Math.floor(room.height / 2),
                    x: room.xCoord + Math.floor(room.width / 2)
                })
                roomToArray(room)

            }
        }

        //loop through coords and add shortest pairs to corridors
        for (let i = 0; i < coords.length - 1; i++) {
            let goal = coords[i + 1]
            let dist = getDist(coords[i], goal)
            for (let j = i + 2; j < coords.length; j++) {
                let temp = getDist(coords[i], coords[j])
                if (temp < dist) {
                    dist = temp
                    goal = coords[j]
                }

            }
            corridorToArray({ y: [coords[i].y, goal.y], x: [[coords[i].x], goal.x] })
        }

        //place player and exit
        player.x = coords[coords.length - 1].x
        player.y = coords[coords.length - 1].y
        MAP[player.y][player.x] = player //very important that only player coords dictate player location

        MAP[coords[0].y][coords[0].x] = portal

        //fills array with chests and monsters
        chestToArray()

        //code that outputs array to screen
        arrayToHTML()
    }

    function getDist(start, goal) {
        Math.abs((start.x - goal.x) * (start.y - goal.y))
    }

    //adds HTML accurate elements to array for rooms
    function roomToArray(room) {
        for (let i = room.yCoord; i < room.yCoord + room.height; i++) {
            for (let j = room.xCoord; j < room.xCoord + room.width; j++) {
                if (!(MAP[i][j] === floor)) {
                    if (i == room.yCoord || i == room.yCoord + room.height - 1) {
                        MAP[i][j] = h_wall
                    } else if (j == room.xCoord || j == room.xCoord + room.width - 1) {
                        MAP[i][j] = v_wall
                    } else {
                        MAP[i][j] = floor
                    }
                }
            }
        }
    }

    //adds HTML accurate elements to array for corridors
    function corridorToArray(c) {
        for (let i = Math.min(...c.y); i < Math.max(...c.y) + 1; i++) {
            MAP[i][c.x[1]] = floor
            if (MAP[i][c.x[1] - 1] === back) {
                MAP[i][c.x[1] - 1] = v_wall
            }
            if (MAP[i][c.x[1] + 1] === back) {
                MAP[i][c.x[1] + 1] = v_wall
            }
        }
        for (let j = Math.min(...c.x); j < Math.max(...c.x) + 1; j++) {
            MAP[c.y[0]][j] = floor
            if (MAP[c.y[0] - 1][j] === back) {
                MAP[c.y[0] - 1][j] = h_wall
            }
            if (MAP[c.y[0] + 1][j] === back) {
                MAP[c.y[0] + 1][j] = h_wall
            }
        }
    }

    //populates map with enemies
    function chestToArray() {
        for (let y = 1; y < GRID_HEIGHT - 1; y++) {
            for (let x = 1; x < GRID_WIDTH - 1; x++) {

                //checks location won't block paths
                let open = true
                for (let i = y - 1; i <= y + 1; i++) {
                    for (let j = x - 1; j <= x + 1; j++) {
                        if (MAP[i][j] != floor) {
                            open = false
                        }
                    }
                }

                //code to place everything
                if (open) {
                    let rng = Math.random() * 100
                    if (rng < 5) {
                        MAP[y][x] = new Chest()
                    }
                }
            }
        }
    }
</script>

</html>